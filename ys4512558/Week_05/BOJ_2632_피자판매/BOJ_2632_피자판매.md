# BOJ 2632 피자판매
# 소요 시간 : 2시간 30분
# 1차 시도 기본 로직
1. 가능한 모든 구간합 부분 집합을 list에 넣어준다. (피자1, 2 모두)
2. 피자1의 모든 구간합 부분 집합을 하나씩 확인하며    
   N - 피자 1의 구간합 부분집합을 이분탐색으로 피자2의 구간합 부분집합에서 찾는다. (로어 바운드 이용)
3. 하지만 이 방법은 최대 피자 조각 크기 1000, 조각 개수 1000으로 O(1000^1000)번의 구간합을 구하는 과정이 필요하다.
4. 또한, 정렬 + 이분 탐색의 시간이 필요하기 때문에 아슬아슬하게 시간에 걸린 것 같다 (70%에서 걸림)
-------------
# 2차 시도 (갓 병익 초이)
1. 최대로 가능한 값은 피자 1개당 1000000이다.
2. 이를 배열로 만들어 실제 부분 누적합 값을 저장하는 것이 아닌    
   개수를 해당 배열에서 카운팅해둔다.
3. 최종적으로 이를 이용해서 dp1[i] + dp2[N - i] == N이 되는 것이므로 이 값을 구해주면 된다.
4. 이때, dp1[i], dp2[N - i]에는 해당 수가 가능한 경우의 수가 들어있으므로    
    이 둘을 곱해주면 둘 중 하나가 0이라면 불가능한 경우로 0을 더한다.
5. 또한, 각각 피자 1개만 사용해서 가능할 수 있으므로 dp1[0] = dp2[0] = 1로 초기화 해둔다. 
-------------
# 알아두면 좋은 점
1. 모듈러 연산 (순환 구조에서 인덱스가 넘어갈 때 모듈로 연산을 사용하면 좋다)
2. 모듈러 연산을 사용하면 인덱스 마지막을 첫번째 인덱스로 매핑시킬 수 있다!.