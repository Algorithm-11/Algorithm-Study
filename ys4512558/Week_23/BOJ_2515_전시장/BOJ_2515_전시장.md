# 소스코드

```Java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int S = Integer.parseInt(st.nextToken());
        Map<Integer, Integer> map = new HashMap<>();
        TreeSet<Picture> treeSet = new TreeSet<>();
        TreeSet<Picture> origin = new TreeSet<>();
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            int h = Integer.parseInt(st.nextToken());
            int c = Integer.parseInt(st.nextToken());
            int cost = map.getOrDefault(h, -1);
            if (cost == -1) {
                map.put(h, c);
                continue;
            }
            map.put(h, Math.max(c, cost));
        }
        for (Integer h : map.keySet()) {
            int c = map.get(h);
            Picture picture = new Picture(h, c);
            treeSet.add(picture);
            origin.add(picture);
        }

        int[] dp = new int[treeSet.last().h + 1];
        int max = 0;
        int size = treeSet.size();
        for (int i = 0; i < size; i++) {
            Picture picture = treeSet.pollFirst();

            int target = picture.h - S;
            int preH = 0;
            while (true) {
                Picture floor = origin.floor(new Picture(target, 0));
                if(floor == null || preH - floor.h >= S) break;
                target = floor.h - 1;
                dp[picture.h] = Math.max(dp[picture.h], dp[floor.h]);
            }
            dp[picture.h] += picture.c;
            max = Math.max(max, dp[picture.h]);
        }

        System.out.println(max);
    }
}

class Picture implements Comparable<Picture> {

    int h, c;

    public Picture(int h, int c) {
        this.h = h;
        this.c = c;
    }

    @Override
    public int compareTo(Picture o) {
        return Integer.compare(this.h, o.h);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Picture picture = (Picture) o;
        return h == picture.h && c == picture.c;
    }

    @Override
    public int hashCode() {
        return Objects.hash(h, c);
    }
}

```

# 소요시간

2시간

# 알고리즘

> DP, 정렬, 이분 탐색

# 풀이

# BOJ 2515 전시장

1. 아이디어가 떠오르지 않아서 분류를 보았다.
2. DP, 이분 탐색인 걸 보고 정렬한 후  
   DP 테이블에 해당 인덱스(높이) 이전에 올 수 있는 최대 가치 + 현재 높이의 가치를 갱신한다.
3. 이때 갱신하는 과정에서 두 개 이상의 값 중 하나만 선택해야하는 경우 최대를 찾는 것이 포인트라고 생각
   > ex) S = 5일때, 현재 : 15이면 최소 6~10사이에 있는 값 중 하나를 선택해야한다.  
   > 10 -> 5 이하를 선택하고 10 선택한 경우 가능  
   > 9 -> 4 이하를 선택하고 9 선택한 경우 가능 등등
   > 위의 경우들 중 가장 최대가 되는 값을 선택해야 함
   > 이때, 현재 선택하려는 값(15)의 가능한 이전 선택의 수 (10)가  
   > 그 이전 선택의 높이보다 S이하만큼 차이가 나면 이를 다 확인해준다.  
   > S 이상이면 이전 높이 선택 + 그 이전 높이 선택 + 현재 높이 선택이 가능하므로
4. 하지만 시간초과가 났다..ㅎ

---
