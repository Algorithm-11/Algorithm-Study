## 소스 코드

https://www.acmicpc.net/source/76093531

## 소모 시간

20분

## 알고리즘

구현, 애드 혹

## 풀이

### 발상

-   문제에 나와있는 연산은 총 두 가지이다.
    -   뒤집기 : 수열을 거꾸로 뒤집는다.
    -   밀기 : 수열을 왼쪽 or 오른쪽으로 한 칸 민다.
-   하지만 수열을 원형으로 생각하면 이 두 연산을 수행한다고 해도 인접 원소에 대한 정보는 바뀌지 않는다는 것을 알 수 있다.
-   따라서 처음 수열의 인접 원소 정보와 결과 수열의 인접 원소 정보가 일치한다면 올바른 문제라고 할 수 있다.

### 구현

-   코드에서는 다음과 같이 구현했다.
    -   `puzzle[number] = i;`
        -   초기 배열의 원소에 대한 순서 저장
    ```
        int curr = problem[i], next = problem[(i + 1) % N];
        int diff = Math.abs(puzzle[curr] - puzzle[next]);`
        if(diff != 1 && diff != N - 1)
    ```
    -   결과 수열의 현재/다음 원소를 초기 배열의 순서와 비교
    -   `1` or `N - 1`이 아닐 경우 올바르지 않은 문제로 출력
