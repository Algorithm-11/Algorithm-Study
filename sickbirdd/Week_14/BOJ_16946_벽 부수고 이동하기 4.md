## 소스 코드

https://www.acmicpc.net/source/77320677

## 소모 시간

40분

## 알고리즘

BFS

## 풀이

### 목표

-   모든 벽에 대해서 벽을 부쉈을 때, 그 위치를 기준으로 이동할 수 있는 칸의 개수를 10으로 나눈 나머지를 출력
-   맵의 형태로 정답을 출력해야 함.

### Naive한 접근

-   이 때, 이동할 수 있는 칸의 개수를 계산하는 방식을 매번 BFS를 수행한다고 생각해보자.
-   `N * M` 이 최대 100만이므로, 50만개의 칸이 벽이고, 50만개의 칸에 대해서 `10^6 * 5 * 10^5 = 5 * 10^11` 이므로 시간 초과가 발생한다.
-   **따라서 이동할 수 있는 칸의 개수를 미리 구해놔야 한다!**

### 풀이

-   이동할 수 있는 칸들은 벽들로 가로막혀 있어서 각각 영역을 구분할 수 있다.
-   따라서 이동할 수 있는 칸들에 대해서 BFS를 수행하였고, 영역을 구분하기 위한 2차원 배열과, 영역의 크기를 저장하기 위한 2차원 배열을 구할 수 있었다.
    -   영역을 구분할 수 있는 인덱스 값을 임의로 설정해서 2차원 배열에 저장하여 각 칸들이 어느 영역에 속해있는 지 알 수 있게 하였다.
    -   또한, 영역의 크기를 BFS를 통해 계산한 뒤, 2차원 배열에 저장하였다. 이후 이동할 수 있는 칸의 개수의 총 합을 계산할 때 활용된다.
-   벽을 기준으로 이동할 수 있는 칸이 어느 영역에 속해있는 지 확인한 후, 영역의 크기를 계속 더해주면서 10으로 나눈 나머지를 직접 계산해서 정답을 구할 수 있었다.
    -   이 때, 같은 영역에 대해 중복으로 계산을 하면 안되므로, HashMap을 활용하여 중복 여부를 확인하였다.
