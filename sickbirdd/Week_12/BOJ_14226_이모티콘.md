## 소스 코드

https://www.acmicpc.net/source/76856444

## 소모 시간

50분

## 알고리즘

BFS

## 풀이

### 발상

-   BFS를 사용하면 되겠다라는 발상을 떠올리기가 힘든 문제이다.
-   **`배열[화면에 있는 이모티콘 개수][클립보드에 있는 이모티콘 개수]`** 인 2차원 배열을 활용하여 중복 방문을 방지하는 것이 문제 해결의 핵심이다.
-   그러면 2차원 배열의 크기는 어떻게 설정해야 할까?
    -   화면에 있는 이모티콘 개수가 S개를 초과했을 때 S개의 이모티콘을 만드려면, 무조건 이모티콘을 1개씩 감소시켜야 한다.
    -   따라서 Naive한 방식으로 최대한 인덱스 에러를 피하기 위해 2 \* S + 1 만큼 배열 크기를 선언했다.
    -   **하지만 화면에 있는 이모티콘 개수가 S를 초과하는 경우는 존재하지 않으므로 배열 크기를 S + 1만큼 선언해도 무방하다.**
    -   **`복사 -> 붙여넣기 -> 감소`** 순으로 연산을 했을 때와 **`복사 -> 감소 -> 붙여넣기`** 순으로 연산을 한 결과는 같기 때문이다.

### 구현

-   BFS를 구현할 때는 화면에 있는 이모티콘 개수와 클립보드에 있는 이모티콘 개수에 대한 정보를 담고 있는 클래스를 `Queue`에 담았다.
-   또한 **`화면에 있는 이모티콘 개수 + 클립보드에 있는 이모티콘 개수 > S`** 인 경우에는 최솟값이 아니라는 것이 보장되므로 붙여넣기를 하지 않게 예외처리를 해줘야 한다.
-   2차원 방문 배열의 초기값은 2 \* 10^9으로 설정했고, **`현재 방문 배열 값 + 1`** 이 **`다음 방문 배열 값`** 보다 작은 경우에만 `Queue`에 담아줘야 한다.
