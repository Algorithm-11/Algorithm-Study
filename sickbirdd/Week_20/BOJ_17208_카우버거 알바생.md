## 소스코드

[클릭하면 백준 코드로 이동됩니다.](https://www.acmicpc.net/source/79362399)

## 소요시간

40분

## 알고리즘

DP

## 풀이

- DP중에서도 KnapSack(배낭 문제)이다!
- 처음에는 3차원 배열을 선언해서 다음과 같은 점화식 설정
    - `dp[주문 순서][햄버거 수][감자튀김 수]`
    - `dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j][k])` (j < i번째 주문 햄버거 수 or k < i번째 주문 감자튀김 수)
    - `dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - i번째 주문 햄버거 수][k - i번째 주문 감자튀김 수] + 1)` (j >= i번째 주문 햄버거 수,  k >= i번째 주문 감자튀김 수)
- 이후에는 2차원 배열로 최적화
    - `dp[햄버거 수][감자튀김 수]`
    - `dp[j][k] = Math.max(dp[j][k], dp[j - i번째 주문 햄버거 수][k - i번째 주문 감자튀김 수] + 1)` (j >= i번째 주문 햄버거 수,  k >= i번째 주문 감자튀김 수) 