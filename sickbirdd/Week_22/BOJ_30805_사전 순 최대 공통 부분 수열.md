## 소스코드

[클릭하면 백준 코드로 이동됩니다.](https://www.acmicpc.net/source/79801744)

## 소요시간

1시간 30분

## 알고리즘

그리디 알고리즘

## 풀이
- 그리디적인 발상을 할 수 있으면 매우 쉽게 해결할 수 있습니다.
- 먼저 사전 순으로 가장 맨 뒤에 있는 숫자를 출력해야 하므로, 숫자가 큰 것이 먼저 나와야 합니다.
- 그리고 숫자가 같다면, 더 많은 경우의 수를 고려해주기 위해 수열의 앞에 있는 숫자부터 고려해줘야 합니다. 
- 이를 활용해서 숫자의 크기를 `내림차순`, 수열의 위치를 `오름차순` 기준으로 `수열 A`와 `수열 B`를 정렬하였습니다.
- 그리고 최대 공통 부분 수열에 숫자를 추가할 때마다, 수열 A와 B의 위치를 매번 저장합니다.
    - 저장된 위치를 다음에 오는 숫자의 위치와 비교해서 더 큰 경우에만 최대 공통 부분 수열에 숫자를 추가해야 한다는 점에 유의합니다.

## 여담
- 어이 없는 실수 때문에 무려 **`1시간`**동안 삽질을 했습니다..
- 원인은 바로 최대 공통 부분 수열을 저장하는 방식에 있었습니다.
    - 최대 공통 부분 수열을 저장할 때 `string`을 사용하여 숫자를 `to_string` 함수로 바꿔줘서 문자열에 더해주는 방식이었습니다.
    - 숫자 단위가 한자릿수일 때는 문제가 전혀 없는 코드이기 때문에 정답이라고 확신했었습니다.
    - **그러나 삽질 끝에 테스트를 할 때 숫자 단위가 `10`을 넘어가면 수열의 길이가 정답과 다르게 나오고, 수열도 이상하게 출력됩니다.**
- 이해하기 쉽게 예시를 들자면 아래와 같습니다.

```
<최대 공통 부분 수열>
12, 4, 3, 2, 1 (string에는 "124321"으로 저장되어 있음.)

<삽질>
6
1 2 4 3 2 1

<정답>
5
12 4 3 2 1
```