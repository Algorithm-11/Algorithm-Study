# 문자열 교환

주차: 3월 2주차
난이도: 실버 1
링크: https://www.acmicpc.net/problem/1522
소요 시간: 30분
알고리즘: 슬라이딩 윈도우

# 풀이 📚

## 사고 과정 🤔

발상을 하는데 아주 고생함. 문제가 당최 뭔 소린지 몰랐음...

문제가 원하는 건 모든 a가 연속되어야 한다.->a의 개수를 구하고 그만큼 윈도우를 구성해라 인듯?
고로 윈도우 사이즈를 문장 내 a의 개수로 정하고, 윈도우를 싹 돌려가며 b가 가장 적게 함유된 경우를 찾으면 그게 답임(b가 n개 일때, n번만 교체하면 됨)
환형인 경우를 고려해야 하니, 윈도우 시작점+윈도우 사이즈가 입력 문장보다 길면 입력 문장 앞부분을 떼다 붙여야함

구현은 5분컷, 발상 난이도가 아주 괘씸함

### 1️⃣ 문장 내 a의 개수를 찾기
---
연속되는 a의 개수를 구하기 위한 과정

문장 내 a의 개수 찾는 코드를 못짜면 하루에 백준 10개씩 풀면서 수련하도록

a의 개수가 곧 윈도우의 사이즈임

### 2️⃣ 윈도우 돌려돌려

0번부터 윈도우를 돌린다. 윈도우 사이즈가 5라고 할때 0~5번째, 1~6번째 이런식으로 배열을 떼다가 b의 개수를 구한다.(최소 b의 개수도 갱신)
만약 배열 사이즈보다 큰 인덱스를 찾아야 되면, % 연산으로 배열 앞에서부터 떼다가 붙이자

---

윈도우 돌리면서 해당 임시 배열에 b 개수가 가장 적은게 답이다

# 전체 코드 🖥️

## 내 코드 😏

```python
tgt=str(input())
a_cnt=tgt.count("a")
min_val=9999
for idx in range(len(tgt)):
    now=[]
    if idx+a_cnt<=len(tgt):
        now=tgt[idx:idx+a_cnt]
    else:
        now=tgt[idx:]+tgt[0:(idx+a_cnt)%len(tgt)]
    min_val=min(min_val,now.count("b"))
print(min_val)
```
