## 소스코드
[여기 클릭해 보세요!](https://github.com/BE-Archive/Algorithm-Study/blob/main/wnso-kim/Week_23/BOJ_22866_탑보기/BOJ_22866_탑보기.java)

## 소요시간
`40분`

## 알고리즘
`DP`

## 풀이
#### [1] 나이브한 접근
`z번째 빌딩`보다 왼쪽에 있는 빌딩 중 높은 빌딩(y)을 찾는다.    
`y번째 빌딩`보다 왼쪽에 있는 빌딩 중 높은 빌딩(x)을 찾는다.    
`x번째 빌딩`보다 왼쪽에 있는 빌딩 중 높은 빌딩(w)을 찾는다.

위를 반복하면 z번째 건물에서 볼 수 있는 왼쪽 건물들을 알 수 있다.

#### [2] DP 관점
w > x > y > z 인 건물이 순서대로 주어 졌을 때,    
각 건물에서 볼 수 있는 왼쪽 건물의 수는 아래 표와 같다.   

![image](https://github.com/BE-Archive/Algorithm-Study/assets/109727039/6334a369-bb38-4d5d-b4ed-5260f13a5ec8)

만약 중간에 가장 높은 건물이 추가 된다면 어떻게 될까?

![image](https://github.com/BE-Archive/Algorithm-Study/assets/109727039/99055cad-31ac-4add-92e8-47e8e57628d8)

위의 그림과 같이 y와 z의 결과가 바뀌게 된다.

`특정 빌딩(z)` 보다 왼쪽에 `높은 빌딩(y)`이 있는 경우,    
`높은 빌딩(y)`의 dp값 +1이 `특정 빌딩(x)`의 dp값이 된다.

#### [3] 결과
왼쪽 빌딩의 결과를 구한 것과 같이, 오른쪽 빌딩의 결과 또한 DP로 구한다.   
출력 조건 중 아래와 같은 문구가 있다.
> 만약 볼 수 있는 건물의 개수가 1개 이상이라면 $i$번째 건물에서 거리가 가장 가까운 건물의 번호 중 작은 번호로 출력한다. 

DP 테이블이 갱신 되는 경우에 `높은 빌딩(y)`의 인덱스를 저장해두면 된다.
```java
// 왼쪽 빌딩 확인 코드 중 일부
if(buildings[j] > buildings[i]){
    dp[i][0] = dp[j][0]+1;
    dp[i][2] = j+1; // 인덱스 저장
    break;
}

// 오른쪽 빌딩 확인 코드 중 일부
if(dp[i][0] == 0 || (i - dp[i][2]+1) > (j-i)){
    dp[i][2] = j+1;
}
```

#### [4] 최적화
`특정 빌딩(z)` 보다 왼쪽에 `높은 빌딩(y)`이 있는 경우는 반복문을 통해 알 수 있다.
단, `특정 빌딩(z)`이 왼쪽에 있는 모든 빌딩 보다 높은 빌딩이라면 어떻게 될까?   
0번째 빌딩까지 높이를 다 확인해야 한다!

이는 0부터 i번째 빌딩까지 높이를 확인할 때, 가장 높은 빌딩의 높이를 변수에 저장해두면 최적화 할 수 있다.
```java
if(max < buildings[i]){
    max = buildings[i];
    continue;
}
```