## 소스코드
[여기 클릭해 보세요!](https://github.com/BE-Archive/Algorithm-Study/blob/main/wnso-kim/Week_14/BOJ_18427_함께블록쌓기/BOJ_18427_함께블록쌓기.java)

## 소요시간
`30분`

## 알고리즘
`DP`

## 발상
한 사람당 블록을 10개 가질 수 있고, 최대 50명 이으므로 10^50의 조합이 나온다.   
모든 조합을 파악할 수 없기 때문에, DP를 사용해 해결한다.  

`블록 3`이 있을 때, 단순 해당 블록만으로 만들 수 있는 높이는 `3`이다.  
하지만 **다른 사람**의 `블록이 2`가 있다면, 두 블록을 이용해 `높이 5`를 만들 수 있다.   
**다른 사람**의 `블록 1`과 **또 다른 사람**의 `블록 1`이 있다면, 세 블록을 이용해 `높이 5`를 만들 수 있다.

즉, 이전 사람들이 만들어둔 `블록의 높이를 저장`해둔다면 기준 높이를 만들 수 있는 경우를 빠르게 파악할 수 있다.   
이때, 같은 높이여도 블록의 조합이 다를 수 있으므로 `높이를 만들 수 있는 조합의 수`를 저장해 사용한다.

## 풀이
#### [1] 1차원 DP 2개를 사용한다. 
H를 초과한 높이를 기록할 필요가 없으니, 길이를 H+1로 한다.   
`oldDP`는 **이전 사람들**로 만들 수 있는 높이의 조합이 저장돼 있다.   
`newDP`는 **이전 사람들의 조합과 현재 사람**이 만들 수 있는 높이의 조합을 저장한다.  
```java
int[] oldDP = new int[MAX+1];
		
for(int[] block: blocks) {
    int[] newDP = new int[MAX+1];
    ...생략
```

#### [2] 조건 판단
어떤 사람이 `1, 3, 5` 블록을 가지고있을 때,   
`높이 5`를 만들고 싶은 경우 이전 사람들의 조합으로 `4, 2, 0`에 해당하는 높이가 몇개인지 파악하면 된다. 

즉, `내가 가지고 있는 블록` + `이전 사람들의 조합`으로 1~H까지 몇개 만들 수 있는지 저장하면 된다.   
그러고 다음 사람의 블럭으로 확인하면 된다.

자신의 블록을 사용해 만들 수 있는 경우는 2가지 이다.   
아래 경우를 파악해서 DP로 해결한다!
- 자신의 블록 만 사용하는 경우
- 다른 블록의 조합 + 자신의 블록



```java
int[] oldDP = new int[MAX+1];
		
for(int[] block: blocks) {
    int[] newDP = new int[MAX+1];

    for(int num=1; num<=MAX; num++) {
        newDP[num] = oldDP[num];

        for(int b: block){
            int minus = num - b;

            if(minus < 0) continue;
            else if(minus == 0) newDP[num] += 1;    // 자신의 블록으로만 해결
            else if(oldDP[minus] > 0) newDP[num] += oldDP[minus];   // 다른사람 도움

            newDP[num] = newDP[num]%10007;
        }
    }
    
    oldDP = newDP;
}
```