## 소스코드
[여기 클릭해 보세요!](https://github.com/BE-Archive/Algorithm-Study/blob/main/wnso-kim/Week_41/BOJ_20437_문자열_게임2/BOJ_20437_문자열_게임2.java)

## 소요시간
`50분`

## 알고리즘
`투 포인터`

## 풀이
문제를 해결하기 위한 목표는 아래와 같다. 
- 알파벳 `X`가 있을 때, 문자열의 양 끝이 `X`인 문자열을 찾는다.(`XABCDX` 형식)
- 해당 문자열에 `X`가 K개 있는지 확인한다.
- 위의 문자열들을 찾아 가장 길이가 `긴 것`과 `짧은 것`을 찾는다.
- 알파벳 `a` ~ `z`까지 확인한다.

<br>
 
#### [V1] 2차원 배열을 활용한 풀이
처음 생각한 방법은 `26(알파벳 개수) * len(문자열의 길이+1)` 2차원 배열(`arr`)을 만들어 해결하는 방법이다.   
문자열 `abac` 가 있을 때, 2차원 배열의 초기값은 아래와 같다.   

| - | 0 | 1 | 2 | 3 | 4 |
| --- | --- | --- | --- | --- | --- |
| a | 0
| b | 0
| c | 0
| d | 0
| ... | ... | ... | ... | ... | ... | 
| z | 0


`arr[a~z][0]`은 알파벳이 몇 번 등장 했는지 저장한다.   
`arr[a~z][1~4]`는 몇 번째 알파벳이 몇 번 인덱스에 위치 했는지 저장한다.  

문자열이 `abac` 이므로 테이블은 아래와 같이 채워진다.
| - | 0 | 1 | 2 | 3 | 4 |
| --- | --- | --- | --- | --- | --- |
| a | 2 | 1 | 3 | - | - |
| b | 1 | 2 | - | - | - |
| c | 1 | 4 | - | - | - |
| d | 0 | - | - | - | - |
| ... | ... | ... | ... | ... | ... | 
| z | 0

`K`가 `2` 라면, `arr[a~z][K~4]`를 순회하며 값이 있는 경우만 아래의 조건을 확인한다.    
| 값이 채워진 `arr[a][2]`만 확인한다.
- 문자열의 길이는 `arr[a][2] - arr[a][2-K+1] + 1`이다.
- 문자열의 길이를 MIN, MAX와 비교해 최신화한다.

이러한 방식으로 MIN, MAX를 찾을 수 있다.
하지만, 해당 방식은 메모리를 많이 사용한다.

<br>

#### [V2] 2차원 큐를 활용한 풀이
2차원 배열과 동일한 방식이지만, 큐의 사이즈를 K개로 고정하면 메모리를 줄일 수 있다.   
즉, `Queue<Integer>[a~z]`를 사용하고, 큐에는 K개의 데이터만 담을 수 있도록 한다.(투 포인터 개념)

```java
for(int i=0; i<length; i++){
    int alp = input[i] - 'a';
    queue[alp].add(i);

    if(queue[alp].size() == K){    // 문자열에서 alphabet 이 K만큼 있는 경우
        int start = queue[alp].peek();
        int end = i;

        min = Math.min(min, end-start+1);
        max = Math.max(max, end-start+1);

        queue[alp].poll();
    }
}
```

<br>

#### 최적화
K가 1인 경우, 모든 테이블을 조회할 필요 없이 정답은 `1 1` 이다.   
바로 출력하면 된다.
```java
// K가 1인 경우
if(K==1){
    System.out.println(1 + " " + 1);
    continue;
}
```
