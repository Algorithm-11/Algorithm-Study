## 풀이 과정
- 타일링 문제 => DP
- 왼쪽 삼각형을 기준으로 세칸(혹은 top이 0이라면 두칸)을 추가해나가면서 개수를 세는 형식으로 구할 수 있다.
    - 이 때, 왼쪽 삼각형이 추가되는 부분을 침범하게도, 안하게도 할 수 있다.
    - 침범할 수 있는 경우는 왼쪽의 기존 삼각형의 제일 오른쪽 아래가 단일 정삼각형으로 채워졌을 때이다.
- 따라서, 전체 경우에서 왼쪽의 기존 삼각형의 제일 오른쪽 아래가 단일 정삼각형인지, 아닌지를 구분할 수 있도록 2차원 DP 배열을 사용하여 문제를 풀이할 수 있다.
    - 이 때, tops 배열에 따라 윗쪽에 삼각형이 있을때와 없을 때의 두 경우로 나눌 수 있다.
- 따라서 전체 경우의 수를 정리하면
  - 위에 삼각형이 있을 때 (tops[i-1]==1)
    - 마지막 정삼각형 칸에 정삼각형 타일이 채워질 경우
    - 마지막 정삼각형 칸에 사다리꼴 타일이 채워질 경우
  - 위에 삼각형이 없을 때 (tops[i-1]==0)
      - 마지막 정삼각형 칸에 정삼각형 타일이 채워질 경우
      - 마지막 정삼각형 칸에 사다리꼴 타일이 채워질 경우
- 위의 경우로 나누어서 생각할 수 있다.

## 코드
```java
package Week_21.PGS_산_모양_타일링;

class PGS_산_모양_타일링 {
    public int solution(int n, int[] tops) {
        int answer = 0;
        int[][] dp = new int[n + 1][2];
        dp[0][0] = 1;

        for (int i = 1; i <= n; i++) {
            if (tops[i - 1] == 1) {
                dp[i][0] = (dp[i - 1][0] * 3 + dp[i - 1][1] * 2) % 10007;
                dp[i][1] = (dp[i - 1][0] + dp[i - 1][1]) % 10007;
            } else {
                dp[i][0] = (dp[i - 1][0] * 2 + dp[i - 1][1]) % 10007;
                dp[i][1] = (dp[i - 1][0] + dp[i - 1][1]) % 10007;
            }
        }

        answer = (dp[n][0] + dp[n][1]) % 10007;
        return answer;
    }
}

```